[toc]

# 进程管理

## 进程与线程

### 进程的概念与特征

#### 进程的概念

##### 引入目的实现

更好的描述和控制程序的并发执行，操作系统的**并发性**和**共享性**（两个最基本特性）

##### 进程控制块（PCB）

###### 目的

为了使参与并发的程序（包含数据）能够独立运行，配备专门的数据结构

###### 用途

描述进程的基本情况和运行状态，控制和管理进程

##### 进程映像（进程实体）

1. 程序段
2. 相关数据段
3. PCB

##### Note

**创建进程**实际上是创建进程映像的 PCB
**撤销进程**实际上是撤销进程的 PCB

进程映像是静态的，进程是动态的

#### 进程的特征

1. 动态性（最基本）：包含创建、活动、暂停、终止等过程，动态的产生、变化、消亡
2. 并发性：多个进程实体同时存在与内存中
3. 独立性：能够独立运行、独立获得资源、独立接受调度的基本单位
4. 异步性：按各自独立的、不可预知的速度向前推进
5. 结构性：进程实体是由程序段+数据段、进程控制块组成

### 进程的状态与转换

1. 运行态：进程正在处理机上运行
2. 就绪态：进程获得除了处理机外的一切资源，一旦得到处理机便可立即运行
3. 阻塞态：进程正在等待某一时间而暂停运行
4. 创建态：进程正在被创建：首先申请一个空白 PCB，并向 PCB 中填写一些控制和管理进程的信息，系统为该进程分配运行时所必须的资源，然后转入就绪态
5. 结束态：进程正在从系统中消失

### 进程控制

一般把进程控制的程序段称为**原语**，特点是**执行期间不允许中断**

#### 进程的创建

1. 为新进程分配一个唯一的进程标识号，并申请一个空白 PCB（有限的）
2. 为进程分配资源、为新进程的程序和数据分配必要的内存空间
3. 初始化 PCB，包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，设置进程的优先级
4. 若进程就绪队列能够接纳新进程，将新进程插入就绪队列

#### 进程的终止

##### 进程终止的原因

1. 正常结束
2. 异常结束
3. 外界干预

##### 过程

1. 根据被终止进程的标识符，检索 PCB，从中读出该进程的状态
2. 被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程
3. 若还有子孙进程，则终止其子孙进程
4. 将资源归还给父进程或操作系统
5. 将 PCB 从队列删除

#### 进程的阻塞和唤醒

##### 进程的阻塞

> 进程的阻塞是进程自身的一种主动行为

1. 通过标识号找到对应的 PCB
2. 若该进程为运行态，则保护现场，将其状态转为阻塞态，停止运行
3. 将 PCB 插入相应的时间等待队列，将处理机资源调度给其他就绪进程

##### 进程的唤醒

1. 在该事件的等待队列中找到相应进程的 PCB
2. 将其从等待队列中移出，并设置状态为就绪态
3. 将该 PCB 插入就绪队列，等待调度

#### 进程切换

1. 保存处理机上下文，包括程序计数器和其他寄存器
2. 更新 PCB 信息
3. 把进程的PCB 移入相应的队列
4. 选择另一个进程执行，并更新 PCB
5. 更新内存管理的数据结构
6. 回复处理机的上下文

### 进程的组织

#### 进程控制块

1. 进程描述信息
   1. 进程标识符
   2. 用户标识符
2. 进程控制和管理信息
   1. 进程当前状态
   2. 进程优先级
3. 资源分配清单
4. 处理机相关信息

#### 程序段

能被进程调度程序调度到 CPU 执行的程序代码段，多个进程可以运行同一个程序

#### 数据段

可以是进程对应的程序加工的原始数据也可以是程序执行时产生的中间或最终结果

### 进程的通信

#### 共享存储

1. 基于数据结构的共享
2. 基于存储区的共享

#### 消息传递

1. 直接通信方式：
2. 间接通信方式：进程把消息发送到某个中间实体，接收进程从中间实体取得消息

#### 管道通信

采用半双全工通信，某一时刻要先写满，写进程先把缓冲区写满才让读进程读

### 线程概念和多线程模型

#### 线程的基本概念

##### 引入线程的目的

减小程序在并发执行时付出的**时空开销**，提高操作系统的**并发性能**

##### 结构特点

+ 进程中的一个实体
+ 系统独立调度和分派的基本单位
+ 线程自己不拥有系统资源
+ 运行中间呈现间断性，也有就绪、阻塞和运行三种状态

#### 线程与进程的比较

| 方式               | 线程                             | 进程                         |
| ------------------ | -------------------------------- | ---------------------------- |
| 调度               | 独立调度的基本单位               | 拥有资源的基本单位           |
| 拥有资源           | 不拥有资源                       | 拥有资源的基本单位           |
| 并发性             | 线程之间可以并发执行             | 进程之间可以并发执行         |
| 系统空间           | 小                               | 大                           |
| 地址空间和其他资源 | 统一进程中的线程间共享进程的资源 | 进程之间的地址空间互相独立   |
| 通信               | 直接读写进程数据段               | 需要进程同步和互斥手段的辅助 |

#### 线程的属性

1. 线程是一个轻型实体，**不拥有系统资源**，每个线程对应一个唯一的标识符和线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态
2. 不同的线程可以调用执行相同的程序，即同一个程序被不同的用户调用时，操作系统把他们创建成不同的线程
3. 同一进程中的各个线程**共享**该进程所拥有的资源
4. 线程是处理机的**独立调度单位**，多个线程可以并发执行
5. 一个线程被创建后就开始它的**生命周期**

#### 线程的实现方式

##### 用户级线程

有关线程管理都由应用程序完成，内核意识不到线程的存在。
应用程序通过线程库设计成多线程程序

##### 内核级线程

线程的管理工作由内核完成

#### 多线程模型

##### 多对一模型

多个用户级线程映射到一个内核级线程

优点：线程管理在用户空间进行，**效率比较高**
缺点：一个线程被阻塞时，整个进程都会被阻塞，多个线程不能并行运行在处理机

##### 一对一模型

每个用户级线程映射到一个内核级线程

优点：**并发能力强**
缺点：创建线程的开销比较大，影响到应用程序的性能

##### 多对多模型

n 个用户级进程映射到 m 个内核级线程，m <= n

## 处理机调度

### 调度的概念

#### 调度的基本概念

对处理机进行分配，从就绪队列中选择一个进程并将处理机分配给它运行，实现进程并发执行

#### 调度的层次

##### 高级调度（作业调度）

内存与辅存之间的调度

##### 中级调度（内存调度）

提高内存的利用率和系统吞吐量

##### 低级调度（进程调度）

从就绪队列选取一个进程将处理机分配给它

#### 三级调度的联系

|      | 高级调度 | 中级调度 | 低级调度 |
| ---- | -------- | -------- | -------- |
| 次数 | 低       | 中等     | 高       |

### 调度的实际、切换、过程

#### 不能进行进程的调度和切换的情况

1. **处理中断过程**
2. 进程处于操作系统**内核程序临界区**
3. 其他需要完全屏蔽中断的**原子操**作过程：加锁、解锁、中断现场保护、恢复等

#### 应该进行进程的调度和切换

1. 发生引起调度条件且无法继续运行下去（非剥夺调度）
2. 中断处理结束或自陷处理结束后（剥夺方式）

### 进程的调度方式

1. 非剥夺调度方式（非抢占方式）
2. 剥夺调度方式（抢占方式）

### 调度的基本准则

1. CPU 利用率
2. 系统吞吐量
3. 周转时间
   1. 作业的周转时间
      $周转时间=作业完成时间-作业提交时间$
   2. 平均周转时间
      $平均周转时间=（作业 1 的周转时间+\cdots +作业 n 的周转时间）/ n $
   3. 带权周转时间
      $代权周转时间=\frac{作业周转时间}{作业实际运行时间}$ 
   4. 平均带权周转时间
      $平均带权周转时间=（作业 1 的带权周转时间+\cdots +作业 n 的带权周转时间）/n$ 
4. 等待时间:进程处于等待处理机状态的时间之和
5. 响应时间：用户提交请求到系统首次产生响应的时间

### 典型的调度算法

#### 先来先服务（FCFS）

+ 属于不可剥夺算法
+ 算法简单，但是效率低
+ 对长作业有利但是对短作业不利
+ 有利于 CPU 繁忙型作业，不利于 IO 繁忙型作业

#### 短作业优先（SJF）

从就绪队列选择估计运行时间最短的进程，将处理机分配给它，直到完成或阻塞才释放

+ 对长作业不利
+ 不能保证紧迫性作业会被及时处理
+ 作业的长短只是根据用户所提供的估计执行时间而定，不一定能做到真正的短作业优先

#### 优先级调度算法

每次从后备队列选择优先级最高的一个或几个作业

##### 分类

###### 是否抢占

+ 非剥夺
+ 剥夺式

###### 优先级是否可以改变

1. 静态优先级
2. 动态优先级

##### 参照原则

1. 交互型进程$>$非交互型进程（前台进程$>$后台进程）
2. 系统进程$>$用户进程
3. IO 型进程$>$计算型进程

#### 高响应比优先调度算法

$响应比 R_P=\frac{等待时间+要求服务时间}{要求服务时间}$

+ 等待时间相同时，要求服务时间越短，响应比越高，有利于短作业
+ 要求服务时间相同时，作业响应比由等待时间决定，实现先来先服务
+ 克服了饥饿状态，兼顾长作业

#### 时间片轮转算法

+ 适用于分时系统
+ 时间片的大小对系统性能影响很大
+ 时间片的长短决定因素：系统的响应时间、就绪队列的进程数目、系统的处理能力

#### 多级反馈队列算法

1. 设置多个就绪队列，赋予不同的优先级，优先级逐次降低
2. 优先级越高的队列中，运行的时间片越小
3. 新进程进入内存之后，首先放在第一级的末尾，按照 FCFS 原则等待调度，如果能在时间片内完成，便可撤离系统，否则进入下一级队列的末尾
4. 仅当第一级队列空时，才调度第二级队列中的进程运行

优势

+ 终端用户：短作业优先
+ 短批处理作业用户：周转时间较短
+ 长批处理作业用户：不会长期 得不到处理

## 进程同步

### 进程同步的基本概念

#### 临界资源

一次只允许一个进程使用的资源称为临界资源，对于临界资源的访问必须互斥进行，访问过程分为：

1. 进入区：检查可否进入临界区
2. 临界区：进程中访问临界资源的那段代码，又称为临界段
3. 退出区：将正在访问临界区的标志清除
4. 剩余区：代码中的其余部分

```cpp
do{
   entry section;//进入区
   critical section;//临界区
   exit section;//退出区
   remainder section;//剩余区
}while(true)
```

#### 同步

也称制约关系，在某些位置协调他们的而工作次序而等待、传递信息所产生的的制约关系

#### 互斥

也称间接制约关系，当一个进程进入临界区使用临界资源，另一个必须等待

应该遵循原则：

+ 空闲让进
+ 忙则等待
+ 有限等待
+ 让权等待

### 实现临界区互斥访问的基本方法

#### 软件实现方法

##### 单标志法

```cpp
//p_0进程
while(turn!=0);
critical section;
turn = 1;
remainder section;

//P_1进程
while(turn!=0);
critical section;
turn = 0;
remainder section;
```

缺点：若某个进程不再进入临界区，另一个也同样无法进入（违背空闲让进），容易造成资源利用不充分

##### 双标志先检查

```cpp
//P_i 进程
while(flag[j]);//1
flag[i]=true;//2
critiacal section;
flag[i]=false;
remainder section;

//P_j 进程
while(flag[i]);//3
flag[j]=true;//4
critiacal section;
flag[j]=false;
remainder section;
```

优点：不用交替进入，可连续使用
缺点：按照 1、2、3、4 的顺序执行，会同时进入临界区（违背忙则等待），问题出在检查和修改操作不能一次进行

##### 双标志后检查

```cpp
//P_i 进程
flag[i]=true;
while(flag[j]);
critiacal section;
flag[i]=false;
remainder section;

//P_j 进程
flag[j]=true;
while(flag[i]);
critiacal section;
flag[j]=false;
remainder section;
```

缺点：双方互相谦让，结果谁也进不了临界区，导致饥饿现象

##### Peterson's Algorithm

```cpp
//P_i 进程
flag[i]=true;turn=j;
while(flag[j]&turn==j);
critical section;
flag[i]=false;
remainder section;

//P_j 进程
flag[j]=true;turn=i;
while(flag[i]&&turn==i);
critical section;
flag[j]=false;
remainder section;
```

#### 硬件实现方法

通过硬件支持实现临界段问题的方法称为**低级方法**，或**元方法**

##### 中断屏蔽方法

禁止一切中短发生，或称之为屏蔽中断、关中断

##### 硬件指令方法

###### TestAndSet指令

这条指令就是原子操作，执行时不允许中断，功能描述如下：

```cpp
bool TestAndSet(bool *lock){
   bool old;
   old = *lock;
   *lock = true;
   return old;
}
```

设置一个共享布尔变量 lock，true 表示正在被占用，初始值为 false，实现进程互斥访问算法描述如下：

```cpp
while TestAndSet(&lock);
进程的临界区代码段;
lock=false;
进程的其他代码段;
```

###### Swap 指令

```cpp 
Swap(bool *a,bool *b){
   bool temp;
   temp = *a;
   *a = *b;
   *b = temp;
}
```

为每个临界资源设置一个共享布尔变量 lock，初始值为 false，每个进程再设置一个局部变量 key，用于与 lock 减缓信息，实现进程互斥访问算法描述如下：

```cpp
key=true;
while(key!=false)
   Swap(&lock,&key);
进程的临界区的代码段;
locl = false;
进程的其他代码段;
```

##### 硬件方法的优缺点 

优点： 适用于任意数目的进程，简单、容易验证其准确性
缺点：等待进入临界区要耗费处理机的时间，不能让权等待

### 信号量机制

#### 整型信号量

定义为一个用于表示资源数目的整数型量 S

```cpp
wait(S){
   while(S<=0);
   S=S-1;
}
signal(S){
   S=S+1;
}
```

未遵循“让权等待”的原则，而是处于“忙等”状态

#### 记录型信号量

```cpp
typedef struct{
   int value;
   struct process *L;
}semaphore;

void wait(semaphore S){
   S.value--;
   if(S.value<0){
      add this process to S.L;
      block(S.L);
   }
}

void signal(semaphore S){
   S.value++;
   if(S.value<=0){
      remove a process P from S.L;
      wakeup(P);
   }
}
```

记录型信号量不存在忙等现象

#### 利用信号量实现同步

只有当语句想执行完成之后语句 y 才可以执行：

```cpp
semaphore S=0;
P1(){
   ...;
   x;
   V(S);
   ...
}
P2(){
   ...
   P(S);
   y;
   ...
}
```

#### 利用信号量实现互斥

```cpp
semaphore S=1;
P1(){
   ...
   P(S);
   进程 P1 的临界区；
   V(S);
   ...
}
P2(){
   ...
   P(S);
   进程 P2 的临界区;
   V(S;
   ...
}
```

### 管程

### 经典同步问题

#### 生产者消费者问题

#### 读者写者问题

#### 哲学家进餐问题

## 死锁

### 死锁的概念

#### 死锁产生的原因

1. 系统资源的竞争
2. 进程推进顺序非法
3. 死锁产生的必要条件
   1. 互斥条件
   2. 不剥夺条件：进程获得资源未使用完成之前，不能被强行夺走
   3. 请求并保持条件：进程已经保持了至少一个资源，又提出新的资源请求，而该资源已经被其他进程占有
   4. 循环等待条件：存在一种进程资源的循环等待链

### 死锁的处理策略

1. 死锁预防：设置限制条件，破坏产生死锁的 4 个必要条件之一
2. 避免死锁：预防系统进入不安全的状态
3. 死锁的检测以及解除

#### 死锁处理策略的比较

||资源分配策略|各种可能模式|主要优点|主要缺点|
|-|-|-|-|-|
|死锁预防|保守，宁可资源闲置|一次请求所有资源，资源剥夺，资源按序分配|适用于突发式处理的进程，不必进行剥夺|效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源|
|死锁避免|是预防和检测的折中（在运行过程中判断是否可能死锁）|寻找安全的允许顺序|不必进行剥夺|必须知道将来的资源需求；进程不能被长时间阻塞|
|死锁检测|宽松，只要允许就分配资源|定期检查死锁是否已经发生|不延长进程初始化时间，允许对死锁进行现场处理|通过剥夺解除死锁，造成损失|

### 死锁预防

1. 破坏互斥条件：不太可行
2. 破坏不剥夺条件：用于状态易于保存和恢复的资源
3. 破坏请求并保持：在运行前一次申请完所需要的全部资源，资源被严重浪费
4. 破坏循环等待条件：采用顺序资源分配法，规定每个进程必须按照编号递增的顺序请求资源，限制了新类型设备的增加

### 死锁避免

#### 银行家算法

### 死锁的检测和解除

#### 资源分配图

#### 死锁定理

#### 死锁解除

1. 资源剥夺法：挂起某些死锁进程，并抢占它的资源
2. 撤销进程法：按照进程优先级和撤销进程代价的高低进行
3. 进程回退法：让一个或多个进程回退到足以避免死锁的地步